import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as n,e as i}from"./app-ygFmrJeo.js";const l={},e=i(`<h1 id="c-基础" tabindex="-1"><a class="header-anchor" href="#c-基础"><span>C++基础</span></a></h1><h2 id="引用" tabindex="-1"><a class="header-anchor" href="#引用"><span>引用</span></a></h2><ol><li>引用是C++提供的语法糖。</li><li>引用定义后不能修改所引用的对象。</li><li>C++的每次函数调用都会重新创建其形参，并用传入的实参对形参进行初始化。 <ol><li>默认都是传值</li><li>要传引用需要将形参定义为引用</li></ol></li></ol><h2 id="const" tabindex="-1"><a class="header-anchor" href="#const"><span>const</span></a></h2><ol><li>声明对象不可变。</li><li><code>const int * a</code>和<code>int const * a</code>等价，都是说指针指向的对象不可变，即禁止<code>*a = 1;</code>。</li><li><code>int * const a</code>是说指针的地址不可变，即禁止<code>int* b = new int; a = b;</code>。</li><li><code>void GetX() const {}</code>只能出现在类成员函数上，说明GetX这个函数不会修改类的成员。</li></ol><h2 id="static" tabindex="-1"><a class="header-anchor" href="#static"><span>static</span></a></h2><p>类或结构体外的static</p><ol><li>静态变量或函数意味着，当需要将这些函数或变量与实际定义的符号链接时，链接器不会在这个翻译单元的作用域之外，寻找那个符号定义。</li><li>extern关键字让链接器可以在其他编译单元寻找符号定义。称external linking。</li><li>static将其声明的变量定义对外部编译单元隐藏。如果extern声明的变量的定义被static声明就会报unresolved external symbol。</li></ol><p>类或结构体内的static</p><ol><li>static 变量，类的所有实例共享同一个static变量。(static变量不是实例的成员，不属于实例)</li><li>static 方法，可以通过类名直接调用。因此，不能访问类的实例。</li></ol><p>局部static-在函数内声明static变量</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">void</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> Func</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">	static</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> i </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">	i</span><span style="color:#D73A49;--shiki-dark:#C678DD;">++</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;">	//... 这里i的作用相当于函数调用计数器。</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>i的作用域为Func函数体。</li><li>i的生存期为程序的生存期。</li></ol><h2 id="enum和enum-class的区别" tabindex="-1"><a class="header-anchor" href="#enum和enum-class的区别"><span>enum和enum class的区别</span></a></h2><p>ChatGPT的回答<br> 在 C++ 中，<code>enum</code> 和 <code>enum class</code> 都用于定义枚举类型，但它们有一些重要的区别：</p><ol><li><strong>作用域：</strong><ul><li><code>enum</code>：枚举值在同一作用域中与枚举类型名共享命名空间。这意味着枚举值可以直接使用，而且可以发生命名冲突。</li><li><code>enum class</code>：枚举值的作用域被限制在枚举类的作用域内，枚举值之间不会发生命名冲突。</li></ul></li><li><strong>底层类型：</strong><ul><li><code>enum</code>：枚举类型的底层类型可以是任何整数类型（char、short、int等），编译器会根据枚举值的范围自动选择适当的底层类型。</li><li><code>enum class</code>：枚举类型的底层类型默认是 <code>int</code>，但可以通过显式指定来更改底层类型。</li></ul></li><li><strong>类型安全：</strong><ul><li><code>enum</code>：枚举值隐式地转换为整数，没有类型检查。</li><li><code>enum class</code>：枚举值不会隐式转换为整数，必须显式转换为底层类型。</li></ul></li><li><strong>隐式转换：</strong><ul><li><code>enum</code>：可以隐式转换为整数类型。</li><li><code>enum class</code>：不会发生隐式转换，需要显式转换为底层类型。</li></ul></li></ol><h2 id="函数指针" tabindex="-1"><a class="header-anchor" href="#函数指针"><span>函数指针</span></a></h2><p>函数的地址是存储器机器语言代码的内存的开始地址</p><p>定义一个指针必须指明其指向的类型，函数指针也一样。函数的类型就是函数的原型。因此，声明一个特定类型函数指针只需要将函数原型中的函数名用(<code>*pf</code>)替换即可，其中pf是指针变量的名称。</p><h2 id="pointe-to-pointer" tabindex="-1"><a class="header-anchor" href="#pointe-to-pointer"><span>pointe-to-pointer</span></a></h2><p>使用场景：一个函数需要返回一个指针给调用者，但同时需要返回一个状态码。状态码通过返回值传递，函数调用者需要的指针只能通过参数传递了。因此需要声明一个指针的指针以pass-by-address。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="color:#032F62;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">using</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> namespace</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;"> std</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">#define</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#E36209;--shiki-dark:#E06C75;font-style:inherit;--shiki-dark-font-style:italic;">x</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">) cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> (x) </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">class</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;"> A</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> a;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">int</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> test</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;">A</span><span style="color:#D73A49;--shiki-dark:#C678DD;">**</span><span style="color:#E36209;--shiki-dark:#E06C75;font-style:inherit;--shiki-dark-font-style:italic;"> pa</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">    PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">pa)).</span><span style="color:#24292E;--shiki-dark:#E06C75;">a</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">);</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // 第一次解引用得到指针，第二次解引用才得到对象的地址</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    static</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> A</span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> tmp </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> A</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E5C07B;">    tmp</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">-&gt;</span><span style="color:#24292E;--shiki-dark:#E06C75;">a</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> =</span><span style="color:#005CC5;--shiki-dark:#D19A66;"> 9</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#56B6C2;">    *</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">pa </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> tmp;</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // 将创建好的指针传递给调用者</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="color:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">int</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    A</span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> ta </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> A</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">    test</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#D73A49;--shiki-dark:#56B6C2;">&amp;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">ta);</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // &amp;ta 是 指针ta本身的地址</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">    PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#24292E;--shiki-dark:#E5C07B;">ta</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">-&gt;</span><span style="color:#24292E;--shiki-dark:#E06C75;">a</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="宏定义中的" tabindex="-1"><a class="header-anchor" href="#宏定义中的"><span>宏定义中的&#39;#&#39;&amp;&#39;##&#39;</span></a></h2><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">#define</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#E36209;--shiki-dark:#E06C75;font-style:inherit;--shiki-dark-font-style:italic;">x</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">) cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> x </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">int</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> a </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#005CC5;--shiki-dark:#D19A66;"> 6</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">    PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(a </span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> a)</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // 输出 36</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>#</code>和<code>##</code>都只用在有参数的宏定义中，且只能用在参数前。</p><p><code>#x</code>：表示将传进来的参数直接看作字符串字面量。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">#define</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#E36209;--shiki-dark:#E06C75;font-style:inherit;--shiki-dark-font-style:italic;">x</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">) cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#24292E;--shiki-dark:#E06C75;"> #x</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">int</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> a </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#005CC5;--shiki-dark:#D19A66;"> 6</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">    PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(a </span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> a)</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // 输出 a * a</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">	PRINT</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#032F62;--shiki-dark:#98C379;">&quot;abc&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // 输出 &quot;abc&quot;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>##x</code>： It permits separate tokens to be joined into a single token, and therefore, can&#39;t be the first or last token in the macro definition. 将两个单独的符号合并成一个，且该符号必须是有效的。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">#define</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> __T</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#E36209;--shiki-dark:#E06C75;font-style:inherit;--shiki-dark-font-style:italic;">x</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">)      L ## x</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // 如果x是字符串 &quot;abc&quot; 则__T(x) 相当与 L&quot;abc&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">#define</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> paster</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">( </span><span style="color:#E36209;--shiki-dark:#E06C75;font-style:inherit;--shiki-dark-font-style:italic;">n</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> ) </span><span style="color:#6F42C1;--shiki-dark:#61AFEF;">printf_s</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">( </span><span style="color:#032F62;--shiki-dark:#98C379;">&quot;token&quot;</span><span style="color:#24292E;--shiki-dark:#E06C75;"> #n</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot; = </span><span style="color:#005CC5;--shiki-dark:#D19A66;">%d</span><span style="color:#032F62;--shiki-dark:#98C379;">&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">, token</span><span style="color:#24292E;--shiki-dark:#E06C75;">##n</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> )</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">int</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> token9 </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#005CC5;--shiki-dark:#D19A66;"> 9</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">int</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">   paster</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="color:#005CC5;--shiki-dark:#D19A66;">9</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">);</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // 输出 token9 = 9</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h2><ul><li>如果你以一个「基类之指针」指向「派生类之对象」，那么经由该指针你只能够调用基类所定义的函数。</li><li>如果基类和派生类都定义了「相同名称之成员函数」，那么通过对象指针调用 <strong>(non-virtual)成员函数</strong> 时，到底调用到哪一个函数，必须视该指针的<strong>原始类型</strong>而定，而不是视指针实际所指之对象的类型而定</li><li>Polymorphism 的目的，就是要让处理「基类之对象」的程序代码，能够完全透通地继续适当处理「派生类之对象」 <ul><li>如果你期望派生类重新定义一个成员函数，那么你应该在基类中把此函数设为virtual。</li><li>以单一指令唤起不同函数，这种性质称为Polymorphism，意思是 &quot;the ability to assume many forms&quot;，也就是多态。</li><li>虚函数是C++语言的Polymorphism 性质以及动态联编的关键。</li><li>既然抽象类中的虚函数不打算被调用，我们就不应该定义它，应该把它设为纯虚函数（在函数声明之后加上&quot;=0&quot; 即可）。</li><li>我们可以说，拥有纯虚函数者为抽象类（abstract Class），以别于所谓的实例类（concrete class)。</li></ul></li></ul><p>抽象类不能产生出对象实体，但是我们可以拥有指向抽象类之指针，以便于操作抽象类的各个派生类。</p><p><strong>虚函数派生下去仍为虚函数，而且可以省略virtual关键词。</strong></p><h3 id="object-slicing与虚函数" tabindex="-1"><a class="header-anchor" href="#object-slicing与虚函数"><span>Object slicing与虚函数</span></a></h3><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="color:#032F62;--shiki-dark:#98C379;"> &lt;iostream.h&gt;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">class</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;"> CObject</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    virtual</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> Serialize</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">() { cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;CObject::Serialize() </span><span style="color:#005CC5;--shiki-dark:#56B6C2;">\\\\</span><span style="color:#032F62;--shiki-dark:#98C379;">n</span><span style="color:#005CC5;--shiki-dark:#56B6C2;">\\\\</span><span style="color:#032F62;--shiki-dark:#98C379;">n&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">class</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;"> CDocument</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> : </span><span style="color:#D73A49;--shiki-dark:#C678DD;">public</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;"> CObject</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> m_data1;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> func</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">        cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;CDocument::func()&quot;</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#61AFEF;">        Serialize</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">virtual</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> Serialize</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">() { cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;CDocument::Serialize() </span><span style="color:#005CC5;--shiki-dark:#56B6C2;">\\\\</span><span style="color:#032F62;--shiki-dark:#98C379;">n</span><span style="color:#005CC5;--shiki-dark:#56B6C2;">\\\\</span><span style="color:#032F62;--shiki-dark:#98C379;">n&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">class</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;"> CMyDoc</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> : </span><span style="color:#D73A49;--shiki-dark:#C678DD;">public</span><span style="color:#6F42C1;--shiki-dark:#E5C07B;"> CDocument</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    int</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> m_data2;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">    virtual</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> Serialize</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">() { cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;CMyDoc::Serialize() </span><span style="color:#005CC5;--shiki-dark:#56B6C2;">\\\\</span><span style="color:#032F62;--shiki-dark:#98C379;">n</span><span style="color:#005CC5;--shiki-dark:#56B6C2;">\\\\</span><span style="color:#032F62;--shiki-dark:#98C379;">n&quot;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">void</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    CMyDoc  mydoc;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    CMyDoc </span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> pmydoc </span><span style="color:#D73A49;--shiki-dark:#C678DD;">=</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> CMyDoc;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;#1 testing&quot;</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E5C07B;">    mydoc</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;">func</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // CDocument::func() CMyDoc::Serialize()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;#2 testing&quot;</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    ((CDocument</span><span style="color:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">)(</span><span style="color:#D73A49;--shiki-dark:#56B6C2;">&amp;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">mydoc))-&gt;</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;">func</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // CDocument::func() CMyDoc::Serialize()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;#3 testing&quot;</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E5C07B;">    pmydoc</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">-&gt;</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;">func</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> // CDocument::func() CMyDoc::Serialize()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    cout </span><span style="color:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="color:#032F62;--shiki-dark:#98C379;"> &quot;#4 testing&quot;</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;">		// 这里出现了object slicing</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">    ((CDocument)mydoc).</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;">func</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;"> //!!! CDocument::func() CDocument::Serialize()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们调用：((CDocument)mydoc).func(); mydoc已经是一个被切割得剩下半条命的对象，而 func 内部调用虚函数 Serialize；后者将使用的「mydoc 的虚函数指针」虽然存在，它的值是什么呢？你是不是隐隐觉得有什么大灾难要发生？</p><p>幸运的是，由于 ((CDocument)mydoc).func() 是个传值而非传址动作，编译器以所谓的复制构造函数（copy constructor）把CDocument 对象内容复制了一份，使得mydoc的vtable 内容与CDocument对象的vtable 相同。</p><h2 id="四种不同的对象生存方式-in-stack、in-heap、global、local-static" tabindex="-1"><a class="header-anchor" href="#四种不同的对象生存方式-in-stack、in-heap、global、local-static"><span><strong>四种不同的对象生存方式（in stack、in heap、global、local static）</strong></span></a></h2><p>既然谈到了static对象，就让我把所有可能的对象生存方式及其构造函数调用时机做个整理。所有作法你都已经在前一节的小程序中看过。</p><p>在C++ 中，有四种方法可以产生一个对象。第一种方法是在堆栈（stack）之中产生它：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>void MyFunc()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    CFoo foo;  // 在堆栈（stack）中产生 foo 对象</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种方法是在堆积（heap）之中产生它：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>void MyFunc()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    CFoo* pFoo = new CFoo(); // 在堆积（heap）中产生对象</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第三种方法是产生一个全局对象（同时也必然是个静态对象）：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>CFoo foo; // 在任何函数范围之外做此动作</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第四种方法是产生一个局部静态对象：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span>void MyFunc()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    static CFoo foo;  // 在函数范围（scope）之内的一个静态对象</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不论任何一种作法，C++ 都会产生一个针对CFoo 构造函数的调用动作。前两种情况，C++ 在配置内存 (来自栈（stack）或堆（heap)之后立刻产生一个隐藏的（你的原始代码中看不出来的）构造函数调用。第三种情况，由于对象实现于任何「函数活动范围（function scope）」之外，显然没有地方来安置这样一个构造函数调用动作。</p><p>是的，第三种情况（静态全局对象）的构造函数调用动作必须靠startup代码帮忙。startup代码是什么？是更早于程序进入点（main 或 WinMain）执行起来的代码，由 C++ 编译器提供，被链接到你的程序中。startup 代码可能做些像函数库初始化、进程信息设立、I/O stream 产生等等动作，以及对 static 对象的初始化动作（也就是调用其构造函数）。</p><p>当编译器编译你的程序，发现一个静态对象，它会把这个对象加到一个串列之中。更精确地说则是，编译器不只是加上此静态对象，它还加上一个指针，指向对象之构造函数及其参数（如果有的话）。把控制权交给程序进入点（main 或 WinMain）之前，startup代码会快速在该串列上移动，调用所有登记有案的构造函数并使用登记有案的参数，于是就初始化了你的静态对象。</p><p>第四种情况（局部静态对象）相当类似C语言中的静态局部变量，只会有一个实体（instance）产生，而且在固定的内存上（既不是stack 也不是heap）。它的构造函数在控制权第一次移转到其声明处（也就是在MyFunc第一次被调用）时被调用。</p><h2 id="字符编码" tabindex="-1"><a class="header-anchor" href="#字符编码"><span>字符编码</span></a></h2><p>首先，关于utf-8的编码说明：有1个字节，有两个字节的（大多数中文），也有三个字节的（少部分其他国家字符）。因此网络传输接收到的数据利用std::string类型来保存也是没问题的。</p><p>C++ std::string存储的是单字节字符，对于中文编码，编码的时候一般是将中文字变成2个字节的gb2312后存储到std::string里面。</p><p>比如：std::string s = &quot;abcd你好&quot;; 长度是8个字节，使用s.length方法测试下即可知道。</p><p>增加<code>u8</code>前缀，则改为使用UTF-8编码，一个中文为3字节。</p>`,56),p=[e];function o(r,t){return a(),n("div",null,p)}const k=s(l,[["render",o],["__file","C__基础.html.vue"]]),h=JSON.parse(`{"path":"/gameengine/C__%E5%9F%BA%E7%A1%80.html","title":"C++基础","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-04-30T00:00:00.000Z","sticky":false,"star":false,"comment":true,"category":["Coding"],"tag":["hazel","cpp"],"description":"C++基础","head":[["meta",{"property":"og:url","content":"https://1e0nhardt.github.io/gameengine/C__%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"宁静致远"}],["meta",{"property":"og:title","content":"C++基础"}],["meta",{"property":"og:description","content":"C++基础"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-25T16:58:41.000Z"}],["meta",{"property":"article:author","content":"leonhardt"}],["meta",{"property":"article:tag","content":"hazel"}],["meta",{"property":"article:tag","content":"cpp"}],["meta",{"property":"article:published_time","content":"2024-04-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-25T16:58:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-30T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-25T16:58:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"leonhardt\\",\\"url\\":\\"/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"引用","slug":"引用","link":"#引用","children":[]},{"level":2,"title":"const","slug":"const","link":"#const","children":[]},{"level":2,"title":"static","slug":"static","link":"#static","children":[]},{"level":2,"title":"enum和enum class的区别","slug":"enum和enum-class的区别","link":"#enum和enum-class的区别","children":[]},{"level":2,"title":"函数指针","slug":"函数指针","link":"#函数指针","children":[]},{"level":2,"title":"pointe-to-pointer","slug":"pointe-to-pointer","link":"#pointe-to-pointer","children":[]},{"level":2,"title":"宏定义中的'#'&'##'","slug":"宏定义中的","link":"#宏定义中的","children":[]},{"level":2,"title":"继承","slug":"继承","link":"#继承","children":[{"level":3,"title":"Object slicing与虚函数","slug":"object-slicing与虚函数","link":"#object-slicing与虚函数","children":[]}]},{"level":2,"title":"四种不同的对象生存方式（in stack、in heap、global、local static）","slug":"四种不同的对象生存方式-in-stack、in-heap、global、local-static","link":"#四种不同的对象生存方式-in-stack、in-heap、global、local-static","children":[]},{"level":2,"title":"字符编码","slug":"字符编码","link":"#字符编码","children":[]}],"git":{"createdTime":1716656321000,"updatedTime":1716656321000,"contributors":[{"name":"1e0nhardt","email":"huwkigane@gmail.com","commits":1}]},"readingTime":{"minutes":9.11,"words":2734},"filePathRelative":"gameengine/C++基础.md","localizedDate":"2024年4月30日","excerpt":""}`);export{k as comp,h as data};
